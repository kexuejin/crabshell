import os
import secrets
import subprocess
import argparse
import shutil

# Configuration
RUST_SHELL_DIR = "loader/app/src/main/rust"
PACKER_DIR = "packer"
SHELL_PROJECT_DIR = "loader"
OUTPUT_DIR = "output"

def generate_key():
    """Generates a 32-byte random key and writes it to config.rs for both Packer and Shell."""
    key_bytes = secrets.token_bytes(32)
    # Format as rust array: [0x12, 0x34, ...]
    rust_array = "[" + ", ".join([f"0x{b:02x}" for b in key_bytes]) + "]"
    
    config_content = f"""
// Auto-generated by pack.py. DO NOT EDIT.
pub const AES_KEY: &[u8; 32] = &{rust_array};
"""

    # Write to Shell
    shell_config_path = os.path.join(RUST_SHELL_DIR, "src", "config.rs")
    os.makedirs(os.path.dirname(shell_config_path), exist_ok=True)
    with open(shell_config_path, "w") as f:
        f.write(config_content)
    print(f"Generated key -> {shell_config_path}")

    # Write to Packer
    packer_config_path = os.path.join(PACKER_DIR, "src", "config.rs")
    os.makedirs(os.path.dirname(packer_config_path), exist_ok=True)
    with open(packer_config_path, "w") as f:
        f.write(config_content)
    print(f"Generated key -> {packer_config_path}")

def build_packer():
    print("Building Packer...")
    subprocess.check_call(["cargo", "build", "--release"], cwd=PACKER_DIR)

def build_shell():
    print("Building Shell (Native)...")
    # Set NDK Home if needed, usually grabbed from env
    env = os.environ.copy()
    # Assuming ANDROID_NDK_HOME is set or cargo-ndk can find it.
    # We can try to detect or use a default if missing, but let's rely on user env first.
    
    subprocess.check_call(
        ["cargo", "ndk", "-t", "arm64-v8a", "-t", "armeabi-v7a", "-o", "../jniLibs", "build", "--release"],
        cwd=RUST_SHELL_DIR,
        env=env
    )
    
    print("Building Shell (APK)...")
    gradlew = "./gradlew" if os.path.exists(os.path.join(SHELL_PROJECT_DIR, "gradlew")) else "gradle"
    subprocess.check_call(
        [gradlew, "assembleRelease"],
        cwd=SHELL_PROJECT_DIR
    )

def pack_apk(target_apk, output_apk):
    packer_bin = os.path.join(PACKER_DIR, "target", "release", "packer")
    shell_apk = os.path.join(SHELL_PROJECT_DIR, "app", "build", "outputs", "apk", "release", "app-release-unsigned.apk")
    
    if not os.path.exists(shell_apk):
        raise FileNotFoundError(f"Shell APK not found at {shell_apk}")
        
    print(f"Packing {target_apk}...")
    subprocess.check_call([
        packer_bin,
        "--shell", shell_apk,
        "--target", target_apk,
        "--output", output_apk
    ])

def sign_apk(apk_path, keystore, ks_pass, key_alias):
    print(f"Signing {apk_path}...")
    # apksigner sign --ks keystore.jks --ks-pass pass:password --ks-key-alias alias apk
    cmd = [
        "apksigner", "sign",
        "--ks", keystore,
        "--ks-pass", f"pass:{ks_pass}"
    ]
    if key_alias:
        cmd.extend(["--ks-key-alias", key_alias])
    cmd.append(apk_path)
    
    subprocess.check_call(cmd)

import json

def load_config(config_path):
    if os.path.exists(config_path):
        with open(config_path, "r") as f:
            return json.load(f)
    return {}

def main():
    parser = argparse.ArgumentParser(description="CrabShell Packer Automation Script")
    parser.add_argument("--config", default="kapp-config.json", help="Path to config file")
    parser.add_argument("--target", help="Path to the target APK to pack")
    parser.add_argument("--output", default="protected.apk", help="Output APK path")
    parser.add_argument("--keystore", help="Path to keystore for signing")
    parser.add_argument("--ks-pass", help="Keystore password")
    parser.add_argument("--key-alias", help="Key alias")
    parser.add_argument("--skip-build", action="store_true", help="Skip building packer and shell")
    
    args = parser.parse_args()
    
    # Load config file
    config = load_config(args.config)
    
    # Merge config with args (args take precedence)
    target = args.target or config.get("target")
    output = args.output if args.output != "protected.apk" else config.get("output", "protected.apk")
    keystore = args.keystore or config.get("keystore")
    ks_pass = args.ks_pass or config.get("ks_pass")
    key_alias = args.key_alias or config.get("key_alias")
    skip_build = args.skip_build or config.get("skip_build", False)

    if not target:
        print("Error: Target APK not specified (use --target or config file).")
        return

    # 1. Generate Key
    generate_key()

    if not skip_build:
        # 2. Build Packer
        build_packer()
        # 3. Build Shell
        build_shell()

    # 4. Pack
    pack_apk(target, output)

    # 5. Sign (if keystore provided)
    if keystore and ks_pass:
        sign_apk(output, keystore, ks_pass, key_alias)
    else:
        print("Warning: No keystore provided. Output APK will be unsigned/invalid.")

    print(f"Done! Protected APK: {output}")

if __name__ == "__main__":
    main()
