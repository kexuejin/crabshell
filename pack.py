import argparse
import json
import os
import secrets
import shutil
import subprocess
import tempfile
import urllib.request
import xml.etree.ElementTree as ET
from typing import Optional, Tuple

RUST_SHELL_DIR = "loader/app/src/main/rust"
PACKER_DIR = "packer"
SHELL_PROJECT_DIR = "loader"
APKTOOL_VERSION = os.environ.get("APKTOOL_VERSION", "2.11.1")
APKTOOL_JAR_URL = f"https://github.com/iBotPeaches/Apktool/releases/download/v{APKTOOL_VERSION}/apktool_{APKTOOL_VERSION}.jar"
from pathlib import Path
ANDROID_NS = "http://schemas.android.com/apk/res/android"
ANDROID_NAME = f"{{{ANDROID_NS}}}name"
ANDROID_VALUE = f"{{{ANDROID_NS}}}value"
ANDROID_AUTHORITIES = f"{{{ANDROID_NS}}}authorities"
ANDROID_EXPORTED = f"{{{ANDROID_NS}}}exported"
ANDROID_INIT_ORDER = f"{{{ANDROID_NS}}}initOrder"


def generate_key():
    key_bytes = secrets.token_bytes(32)
    rust_array = "[" + ", ".join([f"0x{b:02x}" for b in key_bytes]) + "]"

    config_content = f"""
// Auto-generated by pack.py. DO NOT EDIT.
pub const AES_KEY: &[u8; 32] = &{rust_array};
"""

    shell_config_path = os.path.join(RUST_SHELL_DIR, "src", "config.rs")
    os.makedirs(os.path.dirname(shell_config_path), exist_ok=True)
    with open(shell_config_path, "w") as f:
        f.write(config_content)
    print(f"Generated key -> {shell_config_path}")

    packer_config_path = os.path.join(PACKER_DIR, "src", "config.rs")
    os.makedirs(os.path.dirname(packer_config_path), exist_ok=True)
    with open(packer_config_path, "w") as f:
        f.write(config_content)
    print(f"Generated key -> {packer_config_path}")


def ensure_tool_exists(tool: str):
    if shutil.which(tool) is None:
        raise RuntimeError(f"Required tool not found: {tool}")


def sdk_roots() -> list[str]:
    roots = [
        os.environ.get("ANDROID_SDK_ROOT"),
        os.environ.get("ANDROID_HOME"),
        os.path.expanduser("~/Library/Android/sdk"),
        "/usr/local/lib/android/sdk",
    ]
    result = []
    for root in roots:
        if root and os.path.isdir(root):
            result.append(root)
    return result


def find_android_build_tool(tool_name: str) -> Optional[str]:
    in_path = shutil.which(tool_name)
    if in_path:
        return in_path

    candidates: list[Tuple[Tuple[int, ...], str]] = []
    for root in sdk_roots():
        build_tools_dir = os.path.join(root, "build-tools")
        if not os.path.isdir(build_tools_dir):
            continue

        for version in os.listdir(build_tools_dir):
            tool_path = os.path.join(build_tools_dir, version, tool_name)
            if os.path.isfile(tool_path) and os.access(tool_path, os.X_OK):
                parsed = tuple(int(p) if p.isdigit() else 0 for p in version.replace("-", ".").split("."))
                candidates.append((parsed, tool_path))

    if not candidates:
        return None

    candidates.sort(key=lambda item: item[0])
    return candidates[-1][1]


def ensure_apktool_cmd() -> list[str]:
    apktool = shutil.which("apktool")
    if apktool:
        return [apktool]

    java = shutil.which("java")
    if not java:
        raise RuntimeError("apktool not found and java not available for apktool jar fallback")

    codex_home = os.environ.get("CODEX_HOME", os.path.expanduser("~/.codex"))
    tools_dir = os.path.join(codex_home, "tools")
    os.makedirs(tools_dir, exist_ok=True)
    apktool_jar = os.path.join(tools_dir, f"apktool-{APKTOOL_VERSION}.jar")

    if not os.path.exists(apktool_jar):
        print(f"apktool not found, downloading apktool jar {APKTOOL_VERSION}...")
        try:
            urllib.request.urlretrieve(APKTOOL_JAR_URL, apktool_jar)
        except Exception as error:
            raise RuntimeError(f"Failed to download apktool from {APKTOOL_JAR_URL}: {error}")

    return [java, "-jar", apktool_jar]


def build_packer():
    print("Building Packer...")
    env = os.environ.copy()
    cargo_bin = os.path.expanduser("~/.cargo/bin")
    if cargo_bin not in env.get("PATH", ""):
        env["PATH"] = f"{cargo_bin}:{env.get('PATH', '')}"
    subprocess.check_call(["cargo", "build", "--release"], cwd=PACKER_DIR, env=env)


def patch_shell_loader_constants(original_app: str, original_factory: str):
    print(f"Patching Shell loader constants: App={original_app}, Factory={original_factory}")
    factory_java = os.path.join(SHELL_PROJECT_DIR, "app/src/main/java/com/kapp/shell/ShellComponentFactory.java")
    if not os.path.exists(factory_java):
        print(f"Warning: {factory_java} not found, skipping constant patching")
        return

    with open(factory_java, "r") as f:
        content = f.read()

    if original_app:
        content = content.replace("REPLACE_ORIGINAL_APP", original_app)
    if original_factory:
        content = content.replace("REPLACE_ORIGINAL_FACTORY", original_factory)

    with open(factory_java, "w") as f:
        f.write(content)


def build_shell():
    print("Building Shell (Native)...")
    env = os.environ.copy()
    
    cargo_bin = os.path.expanduser("~/.cargo/bin")
    if cargo_bin not in env.get("PATH", ""):
        env["PATH"] = f"{cargo_bin}:{env.get('PATH', '')}"

    if "ANDROID_NDK_HOME" in env:
        ndk_home = env["ANDROID_NDK_HOME"]
        if not os.path.exists(ndk_home):
            print(f"Warning: ANDROID_NDK_HOME is set to '{ndk_home}' but that directory does not exist. Ignoring.")
            del env["ANDROID_NDK_HOME"]

    if "ANDROID_NDK_HOME" not in env:
        print("ANDROID_NDK_HOME not set or invalid. Attempting to detect...")
        possible_paths = [
            os.path.expanduser("~/Library/Android/sdk/ndk"),
            os.path.join(env.get("ANDROID_HOME", ""), "ndk"),
            os.path.join(env.get("ANDROID_SDK_ROOT", ""), "ndk"),
            "/usr/local/lib/android/sdk/ndk",
            os.path.expanduser("~/Library/Android/sdk/ndk-bundle"),
        ]

        found_ndk = None
        for path in possible_paths:
            if path and os.path.isdir(path):
                versions = sorted(
                    [
                        d
                        for d in os.listdir(path)
                        if os.path.isdir(os.path.join(path, d)) and d and d[0].isdigit()
                    ],
                    key=lambda version: version.split("."),
                )
                if versions:
                    found_ndk = os.path.join(path, versions[-1])
                    break
                if os.path.exists(os.path.join(path, "sysroot")):
                    found_ndk = path
                    break

        if found_ndk:
            print(f"Detected NDK at: {found_ndk}")
            env["ANDROID_NDK_HOME"] = found_ndk
        else:
            raise RuntimeError(
                "Could not detect Android NDK. Please set ANDROID_NDK_HOME to your NDK installation."
            )

    subprocess.check_call(
        ["cargo", "ndk", "-t", "arm64-v8a", "-t", "armeabi-v7a", "-o", "../jniLibs", "build", "--release"],
        cwd=RUST_SHELL_DIR,
        env=env,
    )

    print("Building Shell (APK)...")
    gradlew = "./gradlew" if os.path.exists(os.path.join(SHELL_PROJECT_DIR, "gradlew")) else "gradle"
    subprocess.check_call([gradlew, "assembleRelease"], cwd=SHELL_PROJECT_DIR, env=env)


def get_shell_apk_path() -> str:
    shell_apk = os.path.join(
        SHELL_PROJECT_DIR,
        "app",
        "build",
        "outputs",
        "apk",
        "release",
        "app-release-unsigned.apk",
    )
    if not os.path.exists(shell_apk):
        raise FileNotFoundError(f"Shell APK not found at {shell_apk}")
    return shell_apk


def load_string_resources(res_dir: str) -> dict[str, str]:
    values_dir = Path(res_dir)
    result: dict[str, str] = {}
    if not values_dir.exists():
        return result

    for values_path in values_dir.glob("values*/strings.xml"):
        try:
            tree = ET.parse(values_path)
            root = tree.getroot()
        except Exception:
            continue

        for node in root.findall("string"):
            name = node.attrib.get("name")
            if not name:
                continue
            text = "".join(node.itertext()) if node.text is not None else ""
            if text:
                result[name] = text

    return result


def inline_manifest_meta_data_string_values(application: ET.Element, string_table: dict[str, str]):
    if not string_table:
        return

    for element in application.iter():
        value = element.attrib.get(ANDROID_VALUE)
        if not value:
            continue

        if value.startswith("@string/"):
            name = value.split("/", 1)[1]
            resolved = string_table.get(name)
            if resolved:
                element.set(ANDROID_VALUE, resolved)


def ensure_bootstrap_provider(application: ET.Element, provider_class: str):
    for provider in application.findall("provider"):
        if provider.attrib.get(ANDROID_NAME) == provider_class:
            return

    provider = ET.SubElement(application, "provider")
    provider.set(ANDROID_NAME, provider_class)
    provider.set(ANDROID_AUTHORITIES, "${applicationId}.kapp-bootstrap")
    provider.set(ANDROID_EXPORTED, "false")
    provider.set(ANDROID_INIT_ORDER, "1000")


def decode_and_patch_target_manifest(target_apk: str, temp_dir: str) -> Tuple[str, Optional[str], str, str]:
    apktool_cmd = ensure_apktool_cmd()

    decoded_dir = os.path.join(temp_dir, "target_decoded")
    patched_manifest = os.path.join(temp_dir, "AndroidManifest_patched.xml")

    print("Decoding target APK with apktool...")
    subprocess.check_call(apktool_cmd + ["d", "-f", target_apk, "-o", decoded_dir])

    print("Patching decoded AndroidManifest.xml...")
    manifest_path = os.path.join(decoded_dir, "AndroidManifest.xml")
    res_dir = os.path.join(decoded_dir, "res")
    
    provider_class = "com.kapp.shell.BootstrapProvider"
    shell_factory_class = "com.kapp.shell.ShellComponentFactory"
    meta_key = "kapp.original_application"
    factory_meta_key = "kapp.original_factory"

    ET.register_namespace("android", ANDROID_NS)
    tree = ET.parse(manifest_path)
    root = tree.getroot()

    application = root.find("application")
    if application is None:
        raise RuntimeError("No <application> element found in AndroidManifest.xml")

    android_app_factory = f"{{{ANDROID_NS}}}appComponentFactory"
    original_factory = application.attrib.get(android_app_factory, "")
    if original_factory:
        print(f"Original appComponentFactory: '{original_factory}'")
        application.set(android_app_factory, shell_factory_class)

    original_app = application.attrib.get(ANDROID_NAME, "")
    print(f"Original application: '{original_app}'")
    
    # Replace the application class with our shell
    application.set(ANDROID_NAME, "com.kapp.shell.ShellApplication")

    # Inject original app metadata
    original_app_meta = None
    original_factory_meta = None
    for child in application.findall("meta-data"):
        name = child.attrib.get(ANDROID_NAME)
        if name == meta_key:
            original_app_meta = child
        elif name == factory_meta_key:
            original_factory_meta = child

    if original_app_meta is None:
        original_app_meta = ET.SubElement(application, "meta-data")
    original_app_meta.set(ANDROID_NAME, meta_key)
    original_app_meta.set(ANDROID_VALUE, original_app)

    if original_factory:
        if original_factory_meta is None:
            original_factory_meta = ET.SubElement(application, "meta-data")
        original_factory_meta.set(ANDROID_NAME, factory_meta_key)
        original_factory_meta.set(ANDROID_VALUE, original_factory)

    ensure_bootstrap_provider(application, provider_class)

    if res_dir and os.path.exists(res_dir):
        strings = load_string_resources(res_dir)
        inline_manifest_meta_data_string_values(application, strings)

    tree.write(manifest_path, encoding="utf-8", xml_declaration=True)

    print("Rebuilding decoded APK with apktool to get patched binary AndroidManifest.xml...")
    manifest_built_apk = os.path.join(temp_dir, "manifest-only.apk")
    subprocess.check_call(apktool_cmd + ["b", decoded_dir, "-o", manifest_built_apk])

    # Extract compiled binary AndroidManifest.xml from rebuilt minimal APK
    import zipfile

    resources_arsc = os.path.join(temp_dir, "resources.arsc")

    with zipfile.ZipFile(manifest_built_apk, "r") as zf:
        with zf.open("AndroidManifest.xml") as mf, open(patched_manifest, "wb") as out:
            out.write(mf.read())
        
        try:
            with zf.open("resources.arsc") as rsc, open(resources_arsc, "wb") as out:
                out.write(rsc.read())
        except KeyError:
            print("Warning: resources.arsc not found in rebuilt APK.")
            resources_arsc = None

    # We do NOT want to use the rebuilt resources.arsc because it might have a different
    # string pool than the valid binary XML files we are copying from the original APK.
    # Mixing rebuilt ARSC with original binary XMLs causes Resources$NotFoundException.
    # So we return None for resources_arsc to force packer to use the original one.
    return patched_manifest, None, original_app, original_factory


def extract_keep_classes_from_decoded_manifest(decoded_dir: str) -> list[str]:
    manifest_path = os.path.join(decoded_dir, "AndroidManifest.xml")
    if not os.path.exists(manifest_path):
        return []

    try:
        tree = ET.parse(manifest_path)
        root = tree.getroot()
    except Exception:
        return []

    package_name = root.attrib.get("package", "")
    android_name = f"{{{ANDROID_NS}}}name"
    android_app_factory = f"{{{ANDROID_NS}}}appComponentFactory"

    application = root.find("application")
    if application is None:
        return []

    values = []

    # We generally only need to keep the appComponentFactory in plaintext because 
    # the system loads it before our ShellApplication. 
    # BUT with ShellComponentFactory in the loader, we don't need to keep the target's factory.
    # factory = application.attrib.get(android_app_factory, "")
    # if factory:
    #     values.append(factory.strip())

    deduped = []
    seen = set()
    for item in values:
        if item not in seen:
            deduped.append(item)
            seen.add(item)
    return deduped


def extract_keep_prefixes(keep_classes: list[str]) -> list[str]:
    prefixes = []
    seen = set()
    for class_name in keep_classes:
        parts = class_name.split('.')
        if len(parts) >= 2:
            prefix = '.'.join(parts[:-1])
            if prefix not in seen:
                prefixes.append(prefix)
                seen.add(prefix)
    return prefixes


def pack_apk(
    target_apk: str,
    output_apk: str,
    bootstrap_apk: str,
    patched_manifest: str,
    keep_classes: list[str],
    keep_prefixes: list[str],
    keep_libs: list[str],
    encrypt_assets: list[str],
    resources_arsc: Optional[str] = None,
):
    packer_bin = os.path.join(PACKER_DIR, "target", "release", "packer")
    bootstrap_lib_dir = os.path.join(SHELL_PROJECT_DIR, "app", "src", "main", "jniLibs")

    if not os.path.exists(bootstrap_lib_dir):
        raise FileNotFoundError(f"Bootstrap libs directory not found at {bootstrap_lib_dir}")

    print(f"Packing {target_apk} using target-preserving mode...")
    cmd = [
        packer_bin,
        "--target",
        target_apk,
        "--output",
        output_apk,
        "--bootstrap-apk",
        bootstrap_apk,
        "--bootstrap-lib-dir",
        bootstrap_lib_dir,
        "--patched-manifest",
        patched_manifest,
    ]

    if resources_arsc:
        cmd.extend(["--resources", resources_arsc])

    for keep_class in keep_classes:
        cmd.extend(["--keep-class", keep_class])

    for keep_prefix in keep_prefixes:
        cmd.extend(["--keep-prefix", keep_prefix])

    for keep_lib in keep_libs:
        cmd.extend(["--keep-lib", keep_lib])

    for asset_pattern in encrypt_assets:
        cmd.extend(["--encrypt-asset", asset_pattern])

    subprocess.check_call(cmd)


def sign_apk(apk_path, keystore, ks_pass, key_alias):
    print(f"Signing {apk_path}...")
    if ks_pass.startswith("pass:"):
        ks_pass = ks_pass[len("pass:"):]

    apksigner = find_android_build_tool("apksigner")
    if not apksigner:
        raise RuntimeError("apksigner not found in PATH or Android SDK build-tools")

    cmd = [
        apksigner,
        "sign",
        "--ks",
        keystore,
        "--ks-pass",
        f"pass:{ks_pass}",
    ]
    if key_alias:
        cmd.extend(["--ks-key-alias", key_alias])
    cmd.append(apk_path)

    subprocess.check_call(cmd)


def get_default_debug_signing() -> Tuple[str, str, str]:
    debug_keystore = os.path.expanduser("~/.android/debug.keystore")
    debug_alias = "androiddebugkey"
    debug_password = "android"

    if not os.path.exists(debug_keystore):
        ensure_tool_exists("keytool")
        os.makedirs(os.path.dirname(debug_keystore), exist_ok=True)
        print(f"Debug keystore not found, generating: {debug_keystore}")
        subprocess.check_call(
            [
                "keytool",
                "-genkeypair",
                "-v",
                "-keystore",
                debug_keystore,
                "-storepass",
                debug_password,
                "-alias",
                debug_alias,
                "-keypass",
                debug_password,
                "-dname",
                "CN=Android Debug,O=Android,C=US",
                "-keyalg",
                "RSA",
                "-keysize",
                "2048",
                "-validity",
                "10000",
            ]
        )

    return debug_keystore, debug_password, debug_alias


def resolve_signing(
    keystore: Optional[str], ks_pass: Optional[str], key_alias: Optional[str]
) -> Tuple[str, str, Optional[str]]:
    if keystore and ks_pass:
        return keystore, ks_pass, key_alias

    print("No signing config provided. Falling back to Android debug keystore.")
    return get_default_debug_signing()


def load_config(config_path):
    if os.path.exists(config_path):
        with open(config_path, "r") as f:
            return json.load(f)
    return {}


def main():
    parser = argparse.ArgumentParser(description="CrabShell Packer Automation Script")
    parser.add_argument("--config", default="kapp-config.json", help="Path to config file")
    parser.add_argument("--target", help="Path to the target APK to pack")
    parser.add_argument("--output", default="protected.apk", help="Output APK path")
    parser.add_argument("--keystore", help="Path to keystore for signing")
    parser.add_argument("--ks-pass", help="Keystore password")
    parser.add_argument("--key-alias", help="Key alias")
    parser.add_argument("--no-sign", action="store_true", help="Skip APK signing")
    parser.add_argument("--skip-build", action="store_true", help="Skip building packer and shell")
    parser.add_argument("--keep-class", action="append", help="Class names to keep in plaintext (can be specified multiple times)")
    parser.add_argument("--keep-prefix", action="append", help="Package prefixes to keep in plaintext (can be specified multiple times)")
    parser.add_argument("--keep-lib", action="append", help="Library names (without lib prefix or .so) to keep in plaintext (can be specified multiple times)")
    parser.add_argument("--encrypt-asset", action="append", help="Pattern of assets to encrypt (e.g. assets/*.js)")

    args = parser.parse_args()

    config = load_config(args.config)

    target = args.target or config.get("target")
    output = args.output if args.output != "protected.apk" else config.get("output", "protected.apk")
    keystore = args.keystore or config.get("keystore")
    ks_pass = args.ks_pass or config.get("ks_pass")
    key_alias = args.key_alias or config.get("key_alias")
    no_sign = args.no_sign or config.get("no_sign", False)
    skip_build = args.skip_build or config.get("skip_build", False)

    if not target:
        print("Error: Target APK not specified (use --target or config file).")
        return

    # Normalize output path. If user passes a directory, place a default file inside it.
    if os.path.isdir(output) or output.endswith(os.sep):
        target_base = os.path.splitext(os.path.basename(target))[0]
        output = os.path.join(output, f"{target_base}-protected.apk")

    output_parent = os.path.dirname(output)
    if output_parent:
        os.makedirs(output_parent, exist_ok=True)

    generate_key()

    with tempfile.TemporaryDirectory(prefix="kapp-") as temp_dir:
        decoded_dir = os.path.join(temp_dir, "target_decoded")
        # We need to decode and patch the manifest to find original app/factory
        patched_manifest, resources_arsc, original_app, original_factory = decode_and_patch_target_manifest(target, temp_dir)
        
        if not skip_build:
            build_packer()
            # Patch shell source with actual target app/factory names
            patch_shell_loader_constants(original_app, original_factory)
            build_shell()

        bootstrap_apk = get_shell_apk_path()
        
        keep_classes = extract_keep_classes_from_decoded_manifest(decoded_dir)
        manual_keep_classes = args.keep_class or config.get("keep_class", [])
        if isinstance(manual_keep_classes, str):
             manual_keep_classes = [manual_keep_classes]
        keep_classes.extend(manual_keep_classes)
        
        # We no longer automatically extract prefixes as it's too broad.
        # keep_prefixes = extract_keep_prefixes(keep_classes)
        keep_prefixes = []
        
        # Add essential startup prefixes for Kid app only if explicitly needed
        if "Kid" in target:
            # We used to add more here, but let's be minimal to ensure encryption works.
            # Dagger often spans many DEXs, so we'll just keep the classes for now.
            pass
        manual_keep_prefixes = args.keep_prefix or config.get("keep_prefix", [])
        if isinstance(manual_keep_prefixes, str):
            manual_keep_prefixes = [manual_keep_prefixes]
        keep_prefixes.extend(manual_keep_prefixes)
        if keep_classes:
            print(f"Keeping startup classes in plaintext dex: {keep_classes}")
        if keep_prefixes:
            print(f"Keeping startup prefixes in plaintext dex: {keep_prefixes}")
            
        keep_libs = args.keep_lib or config.get("keep_lib", [])
        if isinstance(keep_libs, str):
            keep_libs = [keep_libs]
        # Always keep MMKV if present as it's common for early startup
        if "mmkv" not in keep_libs:
            keep_libs.append("mmkv")
            
        if keep_libs:
            print(f"Keeping early startup libraries in plaintext: {keep_libs}")

        encrypt_assets = args.encrypt_asset or config.get("encrypt_asset", [])
        if isinstance(encrypt_assets, str):
            encrypt_assets = [encrypt_assets]

        pack_apk(target, output, bootstrap_apk, patched_manifest, keep_classes, keep_prefixes, keep_libs, encrypt_assets, resources_arsc)

    if no_sign:
        print("Skipping signing (--no-sign). Output APK may fail to install.")
    else:
        signing_keystore, signing_ks_pass, signing_alias = resolve_signing(keystore, ks_pass, key_alias)
        sign_apk(output, signing_keystore, signing_ks_pass, signing_alias)

    print(f"Done! Protected APK: {output}")


if __name__ == "__main__":
    main()
